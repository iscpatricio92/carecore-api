name: CI

on:
  push:
    branches:
      - main
      - develop
      - 'feature/**'
      - 'fix/**'
  pull_request:
    branches:
      - main
      - develop
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  lint-and-format:
    name: Lint & Format Check
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint

      - name: Check formatting
        run: |
          echo "üîç Verificando formato de archivos..."
          # Verificar formato de archivos en el monorepo
          if npm run format:check; then
            echo "‚úÖ Todos los archivos est√°n correctamente formateados"
          else
            echo "‚ö†Ô∏è  Algunos archivos no est√°n formateados correctamente"
            echo "üí° Ejecuta 'npm run format' para formatear autom√°ticamente"
            exit 1
          fi

      - name: Check commit messages (if PR)
        if: github.event_name == 'pull_request'
        run: |
          echo "üîç Verificando mensajes de commit del PR..."

          # Obtener commits del PR usando las referencias de GitHub
          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"

          echo "üìã Base: $BASE_SHA"
          echo "üìã Head: $HEAD_SHA"

          # Obtener mensajes de commit entre base y head
          COMMITS=$(git log --format=%s $BASE_SHA..$HEAD_SHA 2>/dev/null || git log --format=%s origin/${{ github.base_ref }}..HEAD 2>/dev/null || echo "")

          if [ -z "$COMMITS" ]; then
            echo "‚ö†Ô∏è  No se encontraron commits nuevos para verificar"
            echo "üí° Esto puede ocurrir si el PR no tiene commits nuevos"
            exit 0
          fi

          echo "üìù Encontrados commits para verificar:"
          echo "$COMMITS" | nl
          echo ""

          # Verificar cada commit y contar errores
          HAS_ERRORS=false
          while IFS= read -r commit_msg; do
            if [ -n "$commit_msg" ]; then
              echo "üîç Verificando: $commit_msg"
              if ! echo "$commit_msg" | npx commitlint --config commitlint.config.mjs 2>/dev/null; then
                echo "‚ùå Commit inv√°lido: $commit_msg"
                echo "üí° El mensaje debe seguir el formato: <tipo>(<scope>): <descripci√≥n>"
                echo "   Ejemplo: feat(patients): agregar endpoint de b√∫squeda"
                HAS_ERRORS=true
              else
                echo "‚úÖ Commit v√°lido"
              fi
            fi
          done <<< "$COMMITS"

          if [ "$HAS_ERRORS" = true ]; then
            echo ""
            echo "‚ùå Se encontraron commits con formato inv√°lido"
            echo "üìö Consulta CONTRIBUTING.md para ver el formato correcto"
            exit 1
          fi

          echo ""
          echo "‚úÖ Todos los commits siguen el formato convencional"

  test:
    name: Run Tests
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Wait for PostgreSQL to be ready
        run: |
          echo "‚è≥ Esperando a que PostgreSQL est√© completamente listo..."
          # Install PostgreSQL client to use pg_isready
          sudo apt-get update && sudo apt-get install -y postgresql-client || true
          # Wait for PostgreSQL to be ready (max 30 seconds)
          for i in {1..15}; do
            if pg_isready -h localhost -p 5432 -U test_user 2>/dev/null; then
              echo "‚úÖ PostgreSQL est√° listo"
              break
            fi
            echo "PostgreSQL no est√° listo a√∫n, esperando... ($i/15)"
            sleep 2
          done
          # Verify connection one more time
          if ! pg_isready -h localhost -p 5432 -U test_user 2>/dev/null; then
            echo "‚ö†Ô∏è  PostgreSQL puede no estar completamente listo, pero continuando..."
          fi

      - name: Build shared package
        run: npm run build:shared

      - name: Run unit tests
        working-directory: packages/api
        env:
          NODE_ENV: test
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USER: test_user
          DB_PASSWORD: test_password
          DB_NAME: test_db
          DB_SYNCHRONIZE: 'true'
        run: npm run test:cov

      - name: Run integration tests (coverage)
        working-directory: packages/api
        env:
          NODE_ENV: test
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USER: test_user
          DB_PASSWORD: test_password
          DB_NAME: test_db
          DB_SYNCHRONIZE: 'true'
        run: npm run test:integration:cov

      - name: Run E2E tests (coverage)
        working-directory: packages/api
        env:
          NODE_ENV: test
          DB_TYPE: postgres
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USER: test_user
          DB_PASSWORD: test_password
          DB_NAME: test_db
          DB_SYNCHRONIZE: 'true'
          # ‚ö†Ô∏è SECURITY NOTE: All values below are TEST-ONLY credentials and secrets.
          # These are NOT production values and should NEVER be used in production.
          # They match the default test values in test/helpers/test-module.factory.ts
          # Keycloak variables (tests use MockJwtStrategy but AppModule may need these)
          KEYCLOAK_URL: http://localhost:8080
          KEYCLOAK_REALM: carecore
          KEYCLOAK_CLIENT_ID: carecore-api
          KEYCLOAK_CLIENT_SECRET: test-secret
          # Encryption key for tests (32+ characters) - TEST ONLY, NOT for production
          ENCRYPTION_KEY: test-encryption-key-32-chars-long-for-e2e-tests
        run: npm run test:e2e:cov

      - name: Parse coverage summary (unit, integration, e2e)
        if: always() && github.event_name == 'pull_request'
        id: coverage
        working-directory: packages/api
        run: |
          parse() {
            FILE=$1
            PREFIX=$2
            if [ -f "$FILE" ]; then
              LINES=$(node -e "const s=require('./${FILE}'); console.log(Math.round((s.total.lines.pct)||0));")
              STATEMENTS=$(node -e "const s=require('./${FILE}'); console.log(Math.round((s.total.statements.pct)||0));")
              FUNCTIONS=$(node -e "const s=require('./${FILE}'); console.log(Math.round((s.total.functions.pct)||0));")
              BRANCHES=$(node -e "const s=require('./${FILE}'); console.log(Math.round((s.total.branches.pct)||0));")
            else
              LINES=0; STATEMENTS=0; FUNCTIONS=0; BRANCHES=0
            fi
            echo "${PREFIX}_lines=$LINES" >> $GITHUB_OUTPUT
            echo "${PREFIX}_statements=$STATEMENTS" >> $GITHUB_OUTPUT
            echo "${PREFIX}_functions=$FUNCTIONS" >> $GITHUB_OUTPUT
            echo "${PREFIX}_branches=$BRANCHES" >> $GITHUB_OUTPUT
            echo "Parsed ${PREFIX}: L=$LINES S=$STATEMENTS F=$FUNCTIONS B=$BRANCHES"
          }

          parse "coverage/coverage-summary.json" "unit"
          parse "coverage-integration/coverage-summary.json" "integration"
          parse "coverage-e2e/coverage-summary.json" "e2e"

      - name: Comment PR with coverage
        if: always() && github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN_PAT || secrets.GITHUB_TOKEN }}
          script: |
            const getStatusIcon = (value) => value >= 80 ? '‚úÖ' : value >= 60 ? '‚ö†Ô∏è' : '‚ùå';

            const unit = {
              lines: parseInt('${{ steps.coverage.outputs.unit_lines }}') || 0,
              statements: parseInt('${{ steps.coverage.outputs.unit_statements }}') || 0,
              functions: parseInt('${{ steps.coverage.outputs.unit_functions }}') || 0,
              branches: parseInt('${{ steps.coverage.outputs.unit_branches }}') || 0,
            };
            const integration = {
              lines: parseInt('${{ steps.coverage.outputs.integration_lines }}') || 0,
              statements: parseInt('${{ steps.coverage.outputs.integration_statements }}') || 0,
              functions: parseInt('${{ steps.coverage.outputs.integration_functions }}') || 0,
              branches: parseInt('${{ steps.coverage.outputs.integration_branches }}') || 0,
            };
            const e2e = {
              lines: parseInt('${{ steps.coverage.outputs.e2e_lines }}') || 0,
              statements: parseInt('${{ steps.coverage.outputs.e2e_statements }}') || 0,
              functions: parseInt('${{ steps.coverage.outputs.e2e_functions }}') || 0,
              branches: parseInt('${{ steps.coverage.outputs.e2e_branches }}') || 0,
            };

            const body = `## üß™ Cobertura de Tests (Unit + Integration + E2E)

            | Suite | Lines | Statements | Functions | Branches |
            |-------|-------|------------|-----------|----------|
            | Unit | ${unit.lines}% ${getStatusIcon(unit.lines)} | ${unit.statements}% ${getStatusIcon(unit.statements)} | ${unit.functions}% ${getStatusIcon(unit.functions)} | ${unit.branches}% ${getStatusIcon(unit.branches)} |
            | Integration | ${integration.lines}% ${getStatusIcon(integration.lines)} | ${integration.statements}% ${getStatusIcon(integration.statements)} | ${integration.functions}% ${getStatusIcon(integration.functions)} | ${integration.branches}% ${getStatusIcon(integration.branches)} |
            | E2E | ${e2e.lines}% ${getStatusIcon(e2e.lines)} | ${e2e.statements}% ${getStatusIcon(e2e.statements)} | ${e2e.functions}% ${getStatusIcon(e2e.functions)} | ${e2e.branches}% ${getStatusIcon(e2e.branches)} |

            ---
            _Comentario autom√°tico de CI. Se actualiza en cada push al PR._`;

            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.data.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Cobertura de Tests')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body,
              });
              console.log('‚úÖ Coverage comment updated');
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body,
              });
              console.log('‚úÖ Coverage comment created');
            }

      - name: Upload coverage to Codecov
        if: always()
        uses: codecov/codecov-action@v3
        with:
          files: ./packages/api/coverage/lcov.info
          fail_ci_if_error: false
          token: ${{ secrets.CODECOV_TOKEN }}

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [lint-and-format, test]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      - name: Check build artifacts
        run: |
          if [ ! -d "packages/api/dist" ]; then
            echo "‚ùå Build failed: dist directory not found"
            exit 1
          fi
          if [ ! -d "packages/shared/dist" ]; then
            echo "‚ùå Build failed: shared dist directory not found"
            exit 1
          fi
          echo "‚úÖ Build successful"

  security:
    name: Security Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run Snyk security scan
        uses: snyk/actions/node@master
        continue-on-error: true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high

      - name: Run npm audit
        run: npm audit --audit-level=moderate || true
