# Docker Compose para producción
# Se usa junto con docker-compose.yml base
# Ejemplo: docker-compose -f docker-compose.yml -f docker-compose.production.yml up
# O simplemente: NODE_ENV=production make docker-up (usa este archivo automáticamente)

# En producción, podemos tener configuraciones adicionales como:
# - Restart policies más estrictas
# - Configuraciones de logging
# - Recursos limitados
# - Configuraciones de seguridad adicionales

services:
  postgres:
    restart: always
    # En producción, las variables de entorno vienen de .env.production + .env.local (combinados por Makefile)
    # Considera usar secrets de Docker en lugar de variables de entorno para mayor seguridad

  keycloak:
    restart: always
    # En producción, usar modo production de Keycloak
    command: start
    environment:
      KC_PROXY: edge
      KC_HTTP_RELATIVE_PATH: /

  api:
    restart: always
    # En producción, usar la imagen optimizada (ya configurada en docker-compose.yml base)
    environment:
      NODE_ENV: production
      DB_SYNCHRONIZE: false
    # Healthcheck más estricto en producción
    # Usa $API_INTERNAL_PORT que está disponible como variable de entorno en el contenedor
    # Si no está definida, el healthcheck del Dockerfile usará PORT con default 3000
    healthcheck:
      test:
        [
          'CMD-SHELL',
          'node -e "const port = process.env.API_INTERNAL_PORT || process.env.PORT || \"3000\"; require(\"http\").get(\"http://localhost:\" + port + \"/api\", (r) => {process.exit(r.statusCode === 200 ? 0 : 1)}).on(\"error\", () => process.exit(1))"',
        ]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 40s
