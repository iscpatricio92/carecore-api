# Docker Compose para desarrollo
# Se usa junto con docker-compose.yml base
# Ejemplo: docker-compose -f docker-compose.yml -f docker-compose.development.yml up
# O simplemente: make docker-up (usa este archivo automáticamente cuando NODE_ENV=development)

# En desarrollo, podemos tener configuraciones adicionales como:
# - Volúmenes para hot-reload
# - Servicios adicionales (PgAdmin, etc.)
# - Configuraciones de debugging

services:
  postgres:
    # En desarrollo, podemos exponer más puertos o configuraciones específicas
    # Las variables de entorno vienen de .env.development + .env.local (combinados por Makefile)

  api:
    # En desarrollo, usar el stage "development" que tiene todas las dependencias sin compilar
    build:
      context: .
      dockerfile: Dockerfile
      target: development
    # Cambiar usuario a root temporalmente para desarrollo (necesario para escribir en volúmenes)
    user: root
    # Instalar dependencias primero (necesario porque el volumen anónimo sobrescribe node_modules)
    # Limpiar dist si existe para evitar errores EBUSY
    # Luego ejecutar nest start --watch usando npx
    command: sh -c "npm ci && rm -rf /app/dist && npx nest start --watch"
    volumes:
      # Montar código fuente para hot-reload
      - ./src:/app/src
      # Montar archivos de configuración para que los cambios se reflejen
      - ./package.json:/app/package.json:ro
      - ./tsconfig.json:/app/tsconfig.json:ro
      - ./nest-cli.json:/app/nest-cli.json:ro
      # Excluir node_modules del volumen (usar los del contenedor)
      # No excluir dist como volumen anónimo - dejamos que se cree normalmente
      # Esto evita problemas de bloqueo (EBUSY) cuando nest intenta limpiar/recrear dist
      - /app/node_modules
    environment:
      NODE_ENV: development
      # Variables de base de datos (deben estar en .env.local)
      DB_TYPE: ${DB_TYPE}
      DB_HOST: ${DB_HOST}
      DB_PORT: ${DB_INTERNAL_PORT}
      DB_USER: ${DB_USER}
      DB_PASSWORD: ${DB_PASSWORD}
      DB_NAME: ${DB_NAME}
      DB_SYNCHRONIZE: ${DB_SYNCHRONIZE}
      # Variables de aplicación (deben estar en .env.local)
      PORT: ${API_INTERNAL_PORT}
      API_INTERNAL_PORT: ${API_INTERNAL_PORT}
      # Variables de FHIR (deben estar en .env.local)
      FHIR_VERSION: ${FHIR_VERSION}
      FHIR_BASE_URL: ${FHIR_BASE_URL}
      # Variables de Keycloak (deben estar en .env.local)
      KEYCLOAK_URL: ${KEYCLOAK_URL}
      KEYCLOAK_REALM: ${KEYCLOAK_REALM}
    # En desarrollo, no necesitamos healthcheck estricto
    # Usamos $API_INTERNAL_PORT que está disponible como variable de entorno en el contenedor
    healthcheck:
      test:
        [
          'CMD-SHELL',
          'node -e "require(\"http\").get(\"http://localhost:$API_INTERNAL_PORT/api\", (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"',
        ]
      interval: 60s
      timeout: 10s
      retries: 3
      start_period: 120s
